// Copyright 2018 foundationdb-rs developers, https://github.com/Clikengo/foundationdb-rs/graphs/contributors
// Copyright 2013-2018 Apple, Inc and the FoundationDB project authors.
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

use crate::directory::DirectoryError;
use crate::tuple::Subspace;
use crate::{FdbError, RangeOption, Transaction};

/// Node are used to represent the paths generated by a Directory.
/// They are stored in the `Directory.node_subspace``.
#[derive(Debug)]
pub(crate) struct Node {
    /// The layer is checked during opening, if it does not match the layer
    /// stored, an Error is thrown. It can be used as some ownership's feature
    /// on a path.
    pub(crate) layer: Option<Vec<u8>>,

    /// the current path of a node.
    pub(crate) path: Vec<String>,

    /// the node_space of this node,
    pub(crate) node_subspace: Subspace,
    /// the content_subspace of this node.
    pub(crate) content_subspace: Option<Subspace>,
}

impl Node {
    /// `check_layer` is checking the layer, throwing `IncompatibleLayer` when
    /// the provided layer does not match the one provided.
    pub(crate) fn check_layer(&self, layer: Vec<u8>) -> Result<(), DirectoryError> {
        match &self.layer {
            None => Err(DirectoryError::IncompatibleLayer),
            Some(layer_bytes) => {
                if layer_bytes.len() != layer.len() {
                    Err(DirectoryError::IncompatibleLayer)
                } else {
                    Ok(())
                }
            }
        }
    }

    /// This will use the generated id and:
    ///
    /// * persist the node in the directory subspace
    /// * create the content_subspace and returns it
    pub(crate) async fn create_and_write_content_subspace(
        &mut self,
        trx: &Transaction,
        generated_id: i64,
        parent_subspace: &Subspace,
    ) -> Result<Subspace, DirectoryError> {
        let subspace = parent_subspace.subspace(&generated_id);
        self.persist_content_subspace(&trx, subspace).await
    }

    /// persist a prefix as the content_subspace
    pub(crate) async fn persist_prefix_as_content_subspace(
        &mut self,
        trx: &Transaction,
        prefix: Vec<u8>,
    ) -> Result<(), DirectoryError> {
        let key = self.node_subspace.to_owned();
        trx.set(key.bytes(), &*prefix);
        Ok(())
    }

    /// `persist_content_subspace` will save the provided subspace as the `content_subspace`
    pub(crate) async fn persist_content_subspace(
        &mut self,
        trx: &Transaction,
        subspace: Subspace,
    ) -> Result<Subspace, DirectoryError> {
        let key = self.node_subspace.to_owned();
        trx.set(key.bytes(), subspace.bytes());
        self.content_subspace = Some(subspace.to_owned());
        Ok(subspace)
    }

    /// delete subspace from the node_subspace
    pub(crate) async fn delete_content_from_node_subspace(
        &self,
        trx: &Transaction,
    ) -> Result<(), DirectoryError> {
        println!(
            "deleting node_subspace {:?}",
            &self.node_subspace.to_owned()
        );
        trx.clear(&self.node_subspace.bytes());
        Ok(())
    }

    /// delete subspace from the content_subspace
    pub(crate) async fn delete_content_from_content_subspace(
        &self,
        trx: &Transaction,
    ) -> Result<(), DirectoryError> {
        match self.content_subspace.to_owned() {
            None => Ok(()),
            Some(subspace) => {
                println!(
                    "deleting content_subspace {:?}",
                    &self.content_subspace.to_owned()
                );
                trx.clear_subspace_range(&subspace);
                Ok(())
            }
        }
    }

    /// retrieve the layer used for this node
    pub(crate) async fn retrieve_layer(&mut self, trx: &Transaction) -> Result<(), FdbError> {
        if self.layer == None {
            let key = self.node_subspace.subspace(&b"layer".to_vec());
            self.layer = match trx.get(key.bytes(), false).await {
                Ok(None) => Some(vec![]),
                Err(err) => return Err(err),
                Ok(Some(fdb_slice)) => Some(fdb_slice.to_vec()),
            }
        }
        Ok(())
    }

    /// list sub-folders for a node
    pub(crate) async fn list(&self, trx: &Transaction) -> Result<Vec<String>, DirectoryError> {
        let mut results = vec![];

        let range_option = RangeOption::from(&self.node_subspace.to_owned());

        let fdb_values = trx.get_range(&range_option, 1_024, false).await?;

        for fdb_value in fdb_values {
            let subspace = Subspace::from_bytes(fdb_value.key());
            // stripping from subspace
            let sub_directory: (Vec<u8>, String) = self.node_subspace.unpack(subspace.bytes())?;
            results.push(sub_directory.1);
        }
        Ok(results)
    }
}
