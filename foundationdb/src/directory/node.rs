// Copyright 2018 foundationdb-rs developers, https://github.com/Clikengo/foundationdb-rs/graphs/contributors
// Copyright 2013-2018 Apple, Inc and the FoundationDB project authors.
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

use crate::directory::DirectoryError;
use crate::tuple::Subspace;
use crate::{FdbError, RangeOption, Transaction};

/// Node are used to represent the paths generated by a Directory.
/// They are stored in the `Directory.`
#[derive(Debug)]
pub(crate) struct Node {
    pub(crate) layer: Option<Vec<u8>>,

    pub(crate) paths: Vec<String>,

    pub(crate) node_subspace: Subspace,
    pub(crate) content_subspace: Option<Subspace>,
}

impl Node {
    pub(crate) fn check_layer(&self, layer: Vec<u8>) -> Result<(), DirectoryError> {
        match &self.layer {
            None => Err(DirectoryError::IncompatibleLayer),
            Some(layer_bytes) => {
                if layer_bytes.len() != layer.len() {
                    Err(DirectoryError::IncompatibleLayer)
                } else {
                    Ok(())
                }
            }
        }
    }

    /// This will use the generated id and:
    ///
    /// * persist the node in the directory subspace dedicated to nodes
    /// * create the content_subspace and returns it
    pub(crate) async fn create_subspace(
        &mut self,
        trx: &Transaction,
        generated_id: i64,
        parent_subspace: &Subspace,
    ) -> Result<Subspace, DirectoryError> {
        let new_subspace = parent_subspace.subspace(&generated_id);

        let key = self.node_subspace.to_owned();
        trx.set(key.bytes(), new_subspace.bytes());

        self.content_subspace = Some(new_subspace.to_owned());

        Ok(new_subspace)
    }

    /// retrieve the layer used for this node
    pub(crate) async fn retrieve_layer(&mut self, trx: &Transaction) -> Result<(), FdbError> {
        if self.layer == None {
            let key = self.node_subspace.subspace(&b"layer".to_vec());
            self.layer = match trx.get(key.bytes(), false).await {
                Ok(None) => Some(vec![]),
                Err(err) => return Err(err),
                Ok(Some(fdb_slice)) => Some(fdb_slice.to_vec()),
            }
        }
        Ok(())
    }

    /// list sub-folders for a node
    pub(crate) async fn list(&self, trx: &Transaction) -> Result<Vec<String>, DirectoryError> {
        let mut results = vec![];

        let range_option = RangeOption::from(&self.node_subspace.to_owned());

        let fdb_values = trx.get_range(&range_option, 1_024, false).await?;

        for fdb_value in fdb_values {
            let subspace = Subspace::from_bytes(fdb_value.key());
            // stripping from subspace
            let sub_directory: Vec<u8> = self.node_subspace.unpack(subspace.bytes())?;
            match String::from_utf8(sub_directory.to_owned()) {
                Ok(mut s) => {
                    // s is like "\u{0}\u{2}node-0\u{0}"
                    // we need to remove DEFAULT_SUB_DIRS at the beginning and the padding at the end.
                    // maybe there is a better way to clean it? Unpack?
                    s.remove(0);
                    s.remove(0);
                    s.remove(s.len() - 1);
                    results.push(s);
                }
                Err(err) => {
                    return Err(DirectoryError::Message(format!(
                        "could not decode '{:?}' in utf-8: {}",
                        sub_directory, err
                    )))
                }
            }
        }
        Ok(results)
    }
}
